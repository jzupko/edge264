The test program takes a byte stream formatted according to Annex B.
Remove "-lSDL -DDISPLAY" to measure raw decoding performance.
Add -DDEBUG=1 to pretty print the headers on stdout, -DDEBUG=2 dumps the whole
CABAC parsing on stderr (for comparison against my patched reference software).
There is also a -DFAST_UNALIGNED which I added because ffmpeg has it, but so
far it always slows the decoding.

$ CC edge264_dump.c -mssse3 -std=gnu99 -lSDL -DDISPLAY
$ a.out <video.264



This software is in alpha state, and should not be used as a library yet. All
of the memory structures WILL change consecutively to the implementation of
frame threading.

It is released early such that some features may benefit to
implementers of H.265 decoders (compared mostly to ffmpeg's H.264 decoder):
* A very simple function for searching start codes;
* A faster CABAC engine;
* An Exp-Golomb API with defined bounds, get_ue(ctx, max) and
get_se(ctx, min, max);
* Storing samples in 16bit no matter the actual BitDepth simplifies the code
design a lot and improves the performance of >=9 bit depths thanks to shared
code paths;
* Storage of neighbouring macroblock contexts in a circular buffer lets CurrMb,
MbAddrA, MbAddrB, MbAddrC and MbAddrD be stored sequentially in memory;
* The method of precomputing increments from macroblock neighbours relieves
many of the branches found in CABAC;
* Prediction samples are passed in SIMD registers to the transform functions,
such that almost no intermediate results are committed to memory;
* A heavy use of nested switches to share tail code paths dramatically reduces
code size, such that the whole decoding loop will fit in L1 cache;
* edge264 is not a bitstream validator, so there is neither logging nor explicit
detection of parsing errors;
* error concealment greys areas based on error probability.
